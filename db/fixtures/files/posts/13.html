<p>Ever had a list that's sorta broken up into different lines but is also mostly just uses spaces to delimit items? Ever wanted each item in that list on its own line? Ever want that one-line-per-item list sorted? It's shocking how often I need to do this. Actually it's probably more unfortunate than shocking.</p>
<p>If you find yourself needing to do all that too then you're in luck! It turns out there's plenty of easy ways to turn a bunch of words into a sorted list!</p>
<p>First, a few notes...</p>
<p>Since I'm on OSX I'm accessing my clipboard with <code><a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/pbcopy.1.html">pbcopy</a></code> and <code><a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/pbpaste.1.html">pbpaste</a></code>. If you're on Linux with X11 you can use <code><a href="http://linux.die.net/man/1/xclip">xclip</a></code> or <code><a href="http://linux.die.net/man/1/xsel">xsel</a></code> instead. Obviously you can replace the clipboard paste with some other output command and you can omit the clipboard copy or replace it with some other command.</p>
<p>All of these examples use <code><a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/grep.1.html">grep</a></code> and <code><a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/sort.1.html">sort</a></code>. <code>grep</code> is used here to remove blank lines, I'll just leave it at that since a book could be (and has been apparently) written about <code>grep</code>. <code>sort</code> does exactly what you'd expect, it sorts a file or input. The <code>-f</code> option makes the sorting case insensitive. If you do really want words that start with capital letters to go first then omit that option.</p>
<h2>sed</h2>
<pre>
% pbpaste | <strong>sed 's/[[:space:]]/\'$'\n'/g</strong> | grep -v '^[[:space:]]*$' | sort -f | pbcopy
</pre>
<p><code><a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/sed.1.html">sed</a></code> is <em>ancient</em>. Despite its age it remains incredibly powerful and versatile. If you're on OSX or some other BSD variant then your sed will function somewhat differently from GNU sed. I won't waste a bunch of space explaining the details here, but <a href="http://unix.stackexchange.com/questions/42321/how-can-i-instruct-bsd-sed-to-interpret-escape-sequences-like-n-and-t">this Unix &amp; Linux Stack Exchange question</a> explains it nicely. Basically BSD <code>sed</code> doesn't do escape sequences in output. The best solution I've seen to the problem is in <a href="http://stackoverflow.com/questions/8991275/escaping-newlines-in-sed-replacement-string#comment11267839_8991356">this Stack Overflow comment</a>. If you're on Linux and using GNU <code>sed</code> then this is what you'd do:</p>
<pre>
% xclip -o -selection clipboard | <strong>sed 's/[[:space:]]/\n/g'</strong> | grep -v '^[[:space:]]*$' | sort -f | xclip -i -selection clipboard
</pre>
<p>The <code>s</code> command takes a regular expression, a replacement string, and optionally one or more flags in the form &quot;s/regular expression/replacement string/flags&quot;. The <code>g</code> flag, like it does most places, makes the substitution global.</p>
<h2>tr</h2>
<pre>
% pbpaste | <strong>tr -s '[:space:]' '\n'</strong> | grep -v '^[[:space:]]*$' | sort -f | pbcopy
</pre>
<p><code><a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/tr.1.html">tr</a></code> is similar to <code>sed</code> but much simpler. So simple there isn't much to say. The first argument is a set of characters to replace and the second argument is a corresponding set of characters to replace the first with one-to-one. The <code>-s</code> option squeezes consecutive occurrences of the replacement characters to into a single character.</p>
<h2>awk</h2>
<pre>
% pbpaste | <strong>awk '{gsub(/[[:space:]]+/, "\n"); print}'</strong> | grep -v '^[[:space:]]*$' | sort -f | pbcopy
</pre>
<p><code><a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/awk.1.html">awk</a></code> reads each line and executes the action inside the curly braces for each line. In our case we're using gsub to do a global substitution and then unconditionally printing the line. <code>awk</code> does far more than simple substitution and printing so there's probably a million different ways to accomplish this task. I've met several people who swear by <code>awk</code>, and I can understand why. Personally, I find it to be too awkward (pun sorta intended) for serious use given that alternatives with far fewer rough edges and more extensibility exist.</p>
<h2>Ruby</h2>
<pre>
% pbpaste | <strong>ruby -ne 'puts $_.gsub(/[[:space:]]+/, "\n")'</strong> | grep -v '^[[:space:]]*$' | sort -f | pbcopy
</pre>
<p>This right here is actually the biggest reason why I'm writing this post. Whenever I'm faced with a task involving transforming text my natural inclination is to write a small throwaway script in Ruby to get the job done. Usually those scripts end up being fairly elaborate and proper, in the sense that they could easily be part of an actual program. I like to make it a habit to not write overly terse code. Even when I know I'm going to throw it all away I like my code to be readable with nice descriptive variable names and no magical short cuts. That being said, <a href="http://robm.me.uk/ruby/2013/11/20/ruby-enp.html">this article</a> inspired me to venture forth and try my hand at something arcane and nigh unreadable. I try and avoid writing Ruby that looks like 1990's Perl, but the <code>-n</code> option coupled with <code>-e</code> is just too cool to ignore. I will, however, choose to ignore that the Ruby example looks almost exactly like the <code>awk</code> example. Personally I don't think that's a very flattering comparison.</p>
<p>If all of this seems familiar, it's probably because you've seen <a href="http://devblog.avdi.org/2013/10/16/sorting-lines-in-5-languages/">Avdi Grimm's</a> excellent post on solving <em>almost</em> the same problem in several different languages.</p>
