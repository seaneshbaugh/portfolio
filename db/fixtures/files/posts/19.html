<p>I must admit, I went way too long not knowing about <a href="http://www.gnu.org/software/mit-scheme/documentation/mit-scheme-ref/Association-Lists.html">association lists</a> in Scheme. There's really nothing particularly special about them, they're just a list of pairs. The <code>assq</code>, <code>assv</code>, and <code>assoc</code> functions are what makes them useful. The aforementioned functions work by finding the first pair in the list whose first value matches what is being searched for (using <a href="http://www.gnu.org/software/mit-scheme/documentation/mit-scheme-ref/Equivalence-Predicates.html">different functions to test for equality</a>). This means updating an association list is as simple as using <code>cons</code> to prepend a new pair. This works even if there is already a pair that already has the same &quot;key&quot; (the first element in the pair list).</p>
<p>While prepend and read options are trivial with association lists, things get slightly trickier when you need to come back and traverse the list and use the stored value part of each pair. Take the following association list: <code>(define my-list '((100 3) (100 2) (100 1) (200 2) (200 1)))</code>. If you're building a frequency count of elements in another list you might end up with a structure not unlike this one. Each time you count a new occurrence of a number you just cons a new (value count) pair onto the association list. This means that operations like <code>(assv '100 my-list)</code> will return <code>(100 3)</code> and <code>(assv '200 my-list)</code> will return <code>(200 2)</code> as expected. But what about when we want to reduce the association list but only work with the &quot;final&quot; value for a given key? Naive attempts to use reduce on the association list will give you potentially very incorrect results depending on how many times you have &quot;overwritten&quot; a pair.</p>
<p>An easy way to overcome this problem without resorting to proper hash tables is compacting the association list:</p>
<pre>
(define (compact-alist alist)
  (fold-left (lambda (result pair)
    (if (assv (car pair) result)
      result
      (cons (assv (car pair) alist) result)))
    '() alist))
</pre>
<p>This probably isn't the prettiest way of going about this but at least it's pretty clear what's going on. The association list is reduced with <code><a href="http://www.gnu.org/software/mit-scheme/documentation/mit-scheme-ref/Reduction-of-Lists.html">fold-left</a></code> using a lambda that returns the accumulator result as is if the key has already been added to the result (<code>(car pair)</code> is necessary because <code>assv</code> just looks at the first element in each pair). If the key wasn't found then the first matching pair from the original association list is consed onto the result.</p>
<p>The result of <code>(compact-alist my-list)</code> would be <code>((100 3) (200 2))</code> which in some situations is much more useful and as far as <code>assq</code>, <code>assv</code>, and <code>assoc</code> are concerned is the effectively the same as the non-compacted association list.</p>
